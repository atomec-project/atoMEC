

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>atoMEC.postprocess.conductivity &mdash; atoMEC  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/atoMEC_favicon.png"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> atoMEC
          

          
            
            <img src="../../../_static/atoMEC_horizontal1.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">atoMEC</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">atoMEC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../atoMEC.html">atoMEC</a> &raquo;</li>
        
      <li>atoMEC.postprocess.conductivity</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for atoMEC.postprocess.conductivity</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The conductivity module handles routines used to model the electrical conductivity.</span>

<span class="sd">So far just the Kubo-Greenwood method is implemented.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">* :class:`KuboGreenwood` : Holds various routines needed to compute the Kubo-Greenwood \</span>
<span class="sd">                           conducivity, including its various components. Also contains\</span>
<span class="sd">                           various properties related to the KG conducivity.</span>
<span class="sd">* :class:`SphHamInts`: Holds the routines to construct angular integrals from the \</span>
<span class="sd">                       spherical harmonic functions</span>
<span class="sd">* :class:`RadialInts`: Holds the routines to construct radial integrals from the radial\</span>
<span class="sd">                       KS orbitals</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># standard packages</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="c1"># external packages</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">lpmv</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>

<span class="c1"># internal modules</span>
<span class="kn">from</span> <span class="nn">atoMEC</span> <span class="kn">import</span> <span class="n">mathtools</span>


<div class="viewcode-block" id="KuboGreenwood"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood">[docs]</a><span class="k">class</span> <span class="nc">KuboGreenwood</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for Kubo-Greenwood conductivity and MIS via TRK sum rule.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="n">valence_orbs</span><span class="o">=</span><span class="p">[],</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_orbitals</span> <span class="o">=</span> <span class="n">orbitals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">_xgrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">_eigfuncs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">eigvals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">occnums</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_DOS_w</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">DOS</span> <span class="o">*</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">kpt_int_weight</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spindims</span><span class="p">,</span> <span class="n">lmax_default</span><span class="p">,</span> <span class="n">nmax_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spindims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span>
                <span class="s2">&quot;Kubo-Greenwood is not yet set-up for spin-polarized calculations. </span><span class="se">\</span>
<span class="s2">Please run again with spin-unpolarized input.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">nmax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nmax</span> <span class="o">=</span> <span class="n">nmax_default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nmax</span> <span class="o">=</span> <span class="n">nmax</span>
        <span class="k">if</span> <span class="n">lmax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lmax</span> <span class="o">=</span> <span class="n">lmax_default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lmax</span> <span class="o">=</span> <span class="n">lmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span> <span class="o">=</span> <span class="n">valence_orbs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_orbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;List of tuples: all the possible orbital pairings.&quot;&quot;&quot;</span>
        <span class="n">all_orbs_tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lmax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nmax</span><span class="p">):</span>
                <span class="n">all_orbs_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_orbs</span> <span class="o">=</span> <span class="n">all_orbs_tmp</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_orbs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cond_orbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;List of tuples: all the conduction band orbital pairings.&quot;&quot;&quot;</span>
        <span class="n">cond_orbs_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span>
        <span class="k">for</span> <span class="n">val_orbs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">:</span>
            <span class="n">cond_orbs_tmp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val_orbs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond_orbs</span> <span class="o">=</span> <span class="n">cond_orbs_tmp</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond_orbs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sig_tot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;ndarray: the integrated total conductivity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sig_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_sig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_tt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_tt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sig_tot</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sig_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;ndarray: the integrated cc conductivity component.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sig_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_sig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_cc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_cc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sig_cc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sig_vv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;ndarray: the integrated vv conductivity component.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sig_vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_sig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_vv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_vv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sig_vv</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sig_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;ndarray: the integrated cv conductivity component.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sig_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_sig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_cv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_cv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sig_cv</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N_tot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;float: the total electron number from TRK sum-rule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_tot</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sph_vol</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_tot</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N_free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;float: the free electron number from TRK sum-rule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_cc</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sph_vol</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_free</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sph_vol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;float: the volume of the sphere.&quot;&quot;&quot;</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rmax</span><span class="o">**</span><span class="mf">3.0</span>
        <span class="k">return</span> <span class="n">V</span>

<div class="viewcode-block" id="KuboGreenwood.cond_tot"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.cond_tot">[docs]</a>    <span class="k">def</span> <span class="nf">cond_tot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;tt&quot;</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">maxfreq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">nfreq</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the chosen component of dynamical electrical conductivity sig(w).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component : str, optional</span>
<span class="sd">            the desired component of the conducivity e.g. &quot;cc&quot;, &quot;tt&quot; etc</span>
<span class="sd">        gamma : float, optional</span>
<span class="sd">            smoothing factor</span>
<span class="sd">        maxfreq : float, optional</span>
<span class="sd">            maximum frequency to scan up to</span>
<span class="sd">        nfreq : int, optional</span>
<span class="sd">            number of points in the frequency grid</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cond_tot_ : ndarray</span>
<span class="sd">            dynamical electrical conductivity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
            <span class="n">R1_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_tt</span>
            <span class="n">R2_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_tt</span>
            <span class="n">orb_subset_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span>
            <span class="n">orb_subset_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span>
        <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;cc&quot;</span><span class="p">:</span>
            <span class="n">R1_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_cc</span>
            <span class="n">R2_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_cc</span>
            <span class="n">orb_subset_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span>
            <span class="n">orb_subset_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span>
        <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;cv&quot;</span><span class="p">:</span>
            <span class="n">R1_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_cv</span>
            <span class="n">R2_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_cv</span>
            <span class="n">orb_subset_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span>
            <span class="n">orb_subset_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span>
        <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;vv&quot;</span><span class="p">:</span>
            <span class="n">R1_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R1_int_vv</span>
            <span class="n">R2_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2_int_vv</span>
            <span class="n">orb_subset_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span>
            <span class="n">orb_subset_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Component of conducivity not recognised&quot;</span><span class="p">)</span>

        <span class="n">cond_tot_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_sig_func</span><span class="p">(</span>
            <span class="n">R1_int</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">,</span> <span class="n">maxfreq</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">gamma</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">cond_tot_</span></div>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R1_int_tt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total-total component of the R1 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R1_int_tt_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R1_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R1_int_tt_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R1_int_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conducting-conducting component of the R1 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R1_int_cc_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R1_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R1_int_cc_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R1_int_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conducting-valence component of the R1 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R1_int_cv_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R1_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R1_int_cv_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R1_int_vv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valence-valence component of the R1 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R1_int_vv_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R1_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R1_int_vv_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R2_int_tt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total-total component of the R2 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R2_int_tt_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R2_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R2_int_tt_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R2_int_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conducting-conducting component of the R2 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R2_int_cc_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R2_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R2_int_cc_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R2_int_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conducting-valence component of the R2 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R2_int_cv_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R2_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R2_int_cv_</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span>
    <span class="k">def</span> <span class="nf">R2_int_vv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valence-valence component of the R2 radial integral.&quot;&quot;&quot;</span>
        <span class="n">R2_int_vv_</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R2_int_mat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valence_orbs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">R2_int_vv_</span>

<div class="viewcode-block" id="KuboGreenwood.check_sum_rule"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.check_sum_rule">[docs]</a>    <span class="k">def</span> <span class="nf">check_sum_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the sum rule (see notes) for an orbital :math:`\phi_{nlm}` is satisfied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        l : int</span>
<span class="sd">            angular quantum number</span>
<span class="sd">        n : int</span>
<span class="sd">            principal quantum number</span>
<span class="sd">        m : int</span>
<span class="sd">            magnetic quantum number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum_mom : ndarray</span>
<span class="sd">            the momentum sum rule (see notes)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The expression for the momentum sum rule is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            S_{p} = \sum_{(n_1,l_1,m_1)\neq (n,l,m)}\</span>
<span class="sd">            \frac{|\langle\phi_{nlm}|\nabla|\phi_{n_1 l_1 m_1}\rangle|^2} {\</span>
<span class="sd">            \epsilon_{n_1,l_1,m_1}-\epsilon_{n,l,m}}</span>

<span class="sd">        If the sum rule is satisfied, the summation above should equal 1/2.</span>
<span class="sd">        See Eq. (38) of Ref. [7]_ for an explanation of this sum rule.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [7] Calderin, L. et al, Kubo--Greenwood electrical conductivity formulation</span>
<span class="sd">           and implementation for projector augmented wave datasets&quot;, Comp. Phys Comms.</span>
<span class="sd">           221 (2017): 118-142.</span>
<span class="sd">           `DOI:doi.org/10.1016/j.cpc.2017.08.008</span>
<span class="sd">           &lt;https://doi.org/10.1016/j.cpc.2017.08.008&gt;`__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set up the orbitals to sum over</span>
        <span class="n">new_orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_orbs</span>
        <span class="n">new_orbs</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="c1"># initialize sum_mom and various indices</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span><span class="p">)</span>
        <span class="n">sum_mom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbands</span><span class="p">))</span>

        <span class="c1"># compute the sum rule</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbands</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">new_orbs</span><span class="p">:</span>
                <span class="c1"># the eigenvalue difference</span>
                <span class="n">eig_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                <span class="c1"># only states with |l-l_1|=1 contribute</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># scale eigenfunctions by sqrt(4 pi) due to different normalization</span>
                    <span class="n">orb_l1n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span>
                    <span class="n">orb_ln</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigfuncs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>

                    <span class="c1"># compute the matrix element &lt;\phi|\grad|\phi&gt; and its complex conj</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">l1</span><span class="p">:</span>
                        <span class="n">mel_sq</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_mel_grad_int</span><span class="p">(</span>
                            <span class="n">orb_ln</span><span class="p">,</span> <span class="n">orb_l1n1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span>
                        <span class="p">)</span>
                        <span class="n">mel_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_mel_grad_int</span><span class="p">(</span>
                            <span class="n">orb_l1n1</span><span class="p">,</span> <span class="n">orb_ln</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xgrid</span>
                        <span class="p">)</span>
                        <span class="n">mel_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mel_cc</span> <span class="o">*</span> <span class="n">mel</span><span class="p">)</span>
                    <span class="n">sum_mom</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mel_sq</span> <span class="o">/</span> <span class="n">eig_diff</span>

        <span class="k">return</span> <span class="n">sum_mom</span></div>

<div class="viewcode-block" id="KuboGreenwood.calc_sig"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.calc_sig">[docs]</a>    <span class="k">def</span> <span class="nf">calc_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R1_int</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the *integrated* dynamical conducivity for given subsets (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R1_int : ndarray</span>
<span class="sd">            the &#39;R1&#39; radial component of the integrand (see notes)</span>
<span class="sd">        R2_int : ndarray</span>
<span class="sd">            the &#39;R2&#39; radial component of the integrand (see notes)</span>
<span class="sd">        orb_subset_1 : list of tuples</span>
<span class="sd">            the first subset of orbitals to sum over</span>
<span class="sd">        orb_subset_2 : list of tuples</span>
<span class="sd">            the second subset of orbitals to sum over</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sig : float</span>
<span class="sd">            the integrated dynamical conductivity</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function returns the integrated dynamical conductivity,</span>
<span class="sd">        :math:`\bar{\sigma}=\int_0^\infty d\omega \sigma(\omega)`. The conductivity</span>
<span class="sd">        :math:`\sigma(\omega)` is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \sigma_{S_1,S2}(\omega) = \frac{2\pi}{3V\omega}</span>
<span class="sd">            \sum_{i\in S_1}\sum_{j\in S_2} (f_i - f_j)\</span>
<span class="sd">            |\langle\phi_{i}|\nabla|\phi_{j}\rangle|^2\delta(\epsilon_j-\epsilon_i-\omega),</span>

<span class="sd">        where :math:`S_1,S_2` denote the subsets of orbitals specified in the function&#39;s</span>
<span class="sd">        paramaters, e.g. the conduction-conduction orbitals.</span>

<span class="sd">        In practise, the integral in the above equation is given by a discrete sum due</span>
<span class="sd">        to the presenence of the dirac-delta function.</span>

<span class="sd">        The paramaters `R1_int` and `R2_int` refer to radial integral components in the</span>
<span class="sd">        calculation of the matrix elements. See the supplementary information of</span>
<span class="sd">        Ref. [8]_ for more information on thse components, and the functions</span>
<span class="sd">        :func:`calc_R1_int_mat` and :func:`calc_R2_int_mat` for their definitions.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [8] Callow, T.J. et al.,  &quot;Accurate and efficient computation of mean</span>
<span class="sd">           ionization states with an average-atom Kubo-Greenwood approach.&quot;</span>
<span class="sd">           arXiv preprint arXiv:2203.05863 (2022).</span>
<span class="sd">           `&lt;https://arxiv.org/abs/2203.05863&gt;`__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get matrix dimensions</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">)</span>

        <span class="c1"># compute the angular integrals (see functions for defns)</span>
        <span class="n">P2_int</span> <span class="o">=</span> <span class="n">SphHamInts</span><span class="o">.</span><span class="n">P_mat_int</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">lmax</span><span class="p">)</span>
        <span class="n">P4_int</span> <span class="o">=</span> <span class="n">SphHamInts</span><span class="o">.</span><span class="n">P_mat_int</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lmax</span><span class="p">)</span>

        <span class="c1"># compute the products of the radial and angular integrals</span>
        <span class="n">tmp_mat_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kabcd,ace-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R1_int</span><span class="p">,</span> <span class="n">P2_int</span><span class="p">)</span>
        <span class="n">tmp_mat_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kabcd,ace-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">P4_int</span><span class="p">)</span>
        <span class="n">tmp_mat_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kcdab,cae-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R1_int</span><span class="p">,</span> <span class="n">P2_int</span><span class="p">)</span>
        <span class="n">tmp_mat_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kcdab,cae-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">P4_int</span><span class="p">)</span>

        <span class="c1"># compute the sum over the matrix element |&lt; phi_nlm | nabla | phi_pqm &gt;|^2</span>
        <span class="n">mel_sq_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">tmp_mat_1</span> <span class="o">+</span> <span class="n">tmp_mat_2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tmp_mat_3</span> <span class="o">+</span> <span class="n">tmp_mat_4</span><span class="p">)),</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># compute the f_nl - f_pq matrix</span>
        <span class="n">occ_diff_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_occ_diff_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">)</span>
        <span class="c1"># compute the (e_nl - e_pq)^-1 matrix</span>
        <span class="n">eig_diff_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_eig_diff_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">)</span>

        <span class="c1"># put it all together for the integrated conducivity</span>
        <span class="n">sig_bare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;kln,klnpq-&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DOS_w</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mel_sq_mat</span> <span class="o">*</span> <span class="n">occ_diff_mat</span> <span class="o">/</span> <span class="n">eig_diff_mat</span>
        <span class="p">)</span>

        <span class="c1"># multiply by prefactor 2*pi/V</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sig_bare</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sph_vol</span>

        <span class="k">return</span> <span class="n">sig</span></div>

<div class="viewcode-block" id="KuboGreenwood.calc_sig_func"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.calc_sig_func">[docs]</a>    <span class="k">def</span> <span class="nf">calc_sig_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">R1_int</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">,</span> <span class="n">omega_max</span><span class="p">,</span> <span class="n">n_freq</span><span class="p">,</span> <span class="n">gamma</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the dynamical conducivity for given subsets (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R1_int : ndarray</span>
<span class="sd">            the &#39;R1&#39; radial component of the integrand (see notes)</span>
<span class="sd">        R2_int : ndarray</span>
<span class="sd">            the &#39;R2&#39; radial component of the integrand (see notes)</span>
<span class="sd">        orb_subset_1 : list of tuples</span>
<span class="sd">            the first subset of orbitals to sum over</span>
<span class="sd">        orb_subset_2 : list of tuples</span>
<span class="sd">            the second subset of orbitals to sum over</span>
<span class="sd">        omega_max : float</span>
<span class="sd">            maximum value of the frequency grid</span>
<span class="sd">        n_freq : int</span>
<span class="sd">            number of points in the frequency grid</span>
<span class="sd">        gamma : float</span>
<span class="sd">            smoothing factor for the Lorentzian</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sig_omega, nele: tuple (ndarray, float)</span>
<span class="sd">            * sig_omega: 2d array containing frequency grid and conductivity</span>
<span class="sd">              :math:`\sigma(\omega)`</span>
<span class="sd">            * n_ele: the number of electrons from integration of :math:`\sigma(\omega)`;</span>
<span class="sd">              equivalent to N_ij (for orb subsets ij) in the limit :math:`\gamma\to 0`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function returns the dynamical conductivity, :math:`\sigma(\omega)`,</span>
<span class="sd">        defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \sigma_{S_1,S2}(\omega) &amp;= \frac{2\pi}{3V\omega}</span>
<span class="sd">            \sum_{i\in S_1}\sum_{j\in S_2} (f_i - f_j)\</span>
<span class="sd">            |\langle\phi_{i}|\nabla|\phi_{j}\rangle|^2\</span>
<span class="sd">            \mathcal{L}(\epsilon_i, \epsilon_j, \gamma, \omega) \\</span>
<span class="sd">            \mathcal{L}(\epsilon_i, \epsilon_j, \gamma, \omega)&amp;=\</span>
<span class="sd">            \frac{\gamma}{\pi}\frac{1}{\gamma^2+(\omega+[\epsilon_i-\epsilon_j)])^2}</span>

<span class="sd">        where :math:`S_1,S_2` denote the subsets of orbitals specified in the function&#39;s</span>
<span class="sd">        paramaters, e.g. the conduction-conduction orbitals.</span>

<span class="sd">        As can be seen in the above equation, the dirac-delta function in the definition</span>
<span class="sd">        of the KG conductivity (see `calc_sig` function) is represented by a Lorentzian</span>
<span class="sd">        distribution :math:`\mathcal{L}` to obtain a smooth conductivity function. In</span>
<span class="sd">        the limit :math:`\gamma\to 0`, the Lorentzian becomes a delta function.</span>

<span class="sd">        The paramaters `R1_int` and `R2_int` refer to radial integral components in the</span>
<span class="sd">        calculation of the matrix elements. See the supplementary information of</span>
<span class="sd">        Ref. [8]_ for more information on these components, and the functions</span>
<span class="sd">        :func:`calc_R1_int_mat` and :func:`calc_R2_int_mat` for their definitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the dimensions of the array</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">)</span>

        <span class="c1"># compute the angular momenta integrals</span>
        <span class="n">P2_int</span> <span class="o">=</span> <span class="n">SphHamInts</span><span class="o">.</span><span class="n">P_mat_int</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">lmax</span><span class="p">)</span>
        <span class="n">P4_int</span> <span class="o">=</span> <span class="n">SphHamInts</span><span class="o">.</span><span class="n">P_mat_int</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">lmax</span><span class="p">)</span>

        <span class="c1"># put the angular and radial integrals together</span>
        <span class="n">tmp_mat_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kabcd,ace-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R1_int</span><span class="p">,</span> <span class="n">P2_int</span><span class="p">)</span>
        <span class="n">tmp_mat_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kabcd,ace-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">P4_int</span><span class="p">)</span>
        <span class="n">tmp_mat_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kcdab,cae-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R1_int</span><span class="p">,</span> <span class="n">P2_int</span><span class="p">)</span>
        <span class="n">tmp_mat_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;kcdab,cae-&gt;kabcde&quot;</span><span class="p">,</span> <span class="n">R2_int</span><span class="p">,</span> <span class="n">P4_int</span><span class="p">)</span>

        <span class="n">mel_sq_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">tmp_mat_1</span> <span class="o">+</span> <span class="n">tmp_mat_2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tmp_mat_3</span> <span class="o">+</span> <span class="n">tmp_mat_4</span><span class="p">)),</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># compute the occupation number and eigenvalue differences</span>
        <span class="n">occ_diff_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_occ_diff_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_occnums</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">)</span>
        <span class="n">eig_diff_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_eig_diff_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eigvals</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">)</span>

        <span class="c1"># set up the frequency array - must start a bit above zero</span>
        <span class="c1"># sqrt spacing from origin gives faster convergence wrt nfreq</span>
        <span class="n">omega_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">omega_max</span><span class="p">),</span> <span class="n">n_freq</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># set up lorentzian: requires dummy array to get right shape</span>
        <span class="n">sig_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega_arr</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">omega_dummy_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nbands</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">n_freq</span><span class="p">))</span>
        <span class="n">eig_diff_omega_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;nijkl,nijklm-&gt;nijklm&quot;</span><span class="p">,</span> <span class="n">eig_diff_mat</span><span class="p">,</span> <span class="n">omega_dummy_mat</span>
        <span class="p">)</span>
        <span class="n">eig_diff_lorentz_mat</span> <span class="o">=</span> <span class="n">mathtools</span><span class="o">.</span><span class="n">lorentzian</span><span class="p">(</span>
            <span class="n">omega_arr</span><span class="p">,</span> <span class="n">eig_diff_omega_mat</span><span class="p">,</span> <span class="n">gamma</span>
        <span class="p">)</span>

        <span class="c1"># put everythin together to get conductivity</span>
        <span class="n">mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;kln,klnpq-&gt;klnpq&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DOS_w</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mel_sq_mat</span> <span class="o">*</span> <span class="n">occ_diff_mat</span>
        <span class="p">)</span>
        <span class="n">mat2</span> <span class="o">=</span> <span class="n">eig_diff_lorentz_mat</span> <span class="o">/</span> <span class="n">eig_diff_omega_mat</span>

        <span class="c1"># assign sig(w) and w to sig_omega array dimensions</span>
        <span class="n">sig_omega</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;nijkl,nijklm-&gt;m&quot;</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sph_vol</span>
        <span class="p">)</span>
        <span class="n">sig_omega</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega_arr</span>

        <span class="c1"># integrate and convert to get electron number</span>
        <span class="n">N_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_to_N</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">sig_omega</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">omega_arr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sph_vol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sig_omega</span><span class="p">,</span> <span class="n">N_ele</span></div>

<div class="viewcode-block" id="KuboGreenwood.calc_occ_diff_mat"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.calc_occ_diff_mat">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_occ_diff_mat</span><span class="p">(</span><span class="n">occnums</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix of occupation number diffs -(f_l1n1 - f_l2n2).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        occnums : ndarray</span>
<span class="sd">            the (unweighted FD) KS occupation numbers</span>
<span class="sd">        orb_subset_1 : tuple</span>
<span class="sd">            the first subset of orbitals (eg valence)</span>
<span class="sd">        orb_subset_2 : tuple</span>
<span class="sd">            the second subset of orbitals (eg conduction)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        occ_diff_mat : ndarray</span>
<span class="sd">            the occupation number difference matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">occnums</span><span class="p">)</span>
        <span class="n">occ_diff_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbands</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">orb_subset_1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">orb_subset_2</span><span class="p">:</span>
                <span class="n">occ_diff</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">occnums</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">-</span> <span class="n">occnums</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">])</span>
                <span class="c1"># integral is one-sided wrt energy differences</span>
                <span class="n">occ_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">occ_diff</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">occ_diff</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="c1"># only terms with l1 = l2 +/- 1 will contribute to final answer</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">occ_diff_mat</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">occ_diff</span>
        <span class="k">return</span> <span class="n">occ_diff_mat</span></div>

<div class="viewcode-block" id="KuboGreenwood.calc_eig_diff_mat"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.calc_eig_diff_mat">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_eig_diff_mat</span><span class="p">(</span><span class="n">eigvals</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix of eigenvalue differences e_l1n1 - e_ln2n2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigvals : ndarray</span>
<span class="sd">            the KS energy eigenvalues</span>
<span class="sd">        orb_subset_1 : tuple</span>
<span class="sd">            the first subset of orbitals (eg valence)</span>
<span class="sd">        orb_subset_2 : tuple</span>
<span class="sd">            the second subset of orbitals (eg conduction)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        occ_diff_mat : ndarray</span>
<span class="sd">            the occupation number difference matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span>
        <span class="n">eig_diff_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbands</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">eig_diff_mat</span> <span class="o">+=</span> <span class="mf">1e-6</span>

        <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">orb_subset_1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">orb_subset_2</span><span class="p">:</span>
                <span class="n">eig_diff</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">-</span> <span class="n">eigvals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span>
                <span class="c1"># integral is one-sided wrt energy differences</span>
                <span class="n">eig_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eig_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eig_diff</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>
                <span class="c1"># only terms with l1 = l2 +/- 1 will contribute to final answer</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eig_diff_mat</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_diff</span>
        <span class="k">return</span> <span class="n">eig_diff_mat</span></div>

<div class="viewcode-block" id="KuboGreenwood.calc_mel_grad_int"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.calc_mel_grad_int">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_mel_grad_int</span><span class="p">(</span><span class="n">orb_l1n1</span><span class="p">,</span> <span class="n">orb_l2n2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the matrix element :math:`|&lt;\phi_{n1l1}|\nabla|\phi_{n1l2}&gt;|^2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orb_l1n1 : ndarray</span>
<span class="sd">            l1,n1 radial KS orbital</span>
<span class="sd">        orb_l2n2 : ndarray</span>
<span class="sd">            l2,n2 radial KS orbital</span>
<span class="sd">        l1 : int</span>
<span class="sd">            1st angular momentum quantum number</span>
<span class="sd">        n1 : int</span>
<span class="sd">            1st principal quantum number</span>
<span class="sd">        l2 : int</span>
<span class="sd">            2nd angular momentum quantum number</span>
<span class="sd">        n2 : int</span>
<span class="sd">            2nd principal quantum number</span>
<span class="sd">        m : int</span>
<span class="sd">            magnetic quantum number</span>
<span class="sd">        xgrid : ndarray</span>
<span class="sd">            log grid</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mel_grad_int : float</span>
<span class="sd">            the matrix element :math:`|&lt;\phi_{n1l1}|\nabla|\phi_{n1l2}&gt;|^2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R1_int</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R1_int</span><span class="p">(</span><span class="n">orb_l1n1</span><span class="p">,</span> <span class="n">orb_l2n2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>
        <span class="n">R2_int</span> <span class="o">=</span> <span class="n">RadialInts</span><span class="o">.</span><span class="n">calc_R2_int</span><span class="p">(</span><span class="n">orb_l1n1</span><span class="p">,</span> <span class="n">orb_l2n2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>

        <span class="n">mel_grad_int</span> <span class="o">=</span> <span class="n">R1_int</span> <span class="o">*</span> <span class="n">SphHamInts</span><span class="o">.</span><span class="n">P_int</span><span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">R2_int</span> <span class="o">*</span> <span class="n">SphHamInts</span><span class="o">.</span><span class="n">P_int</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mel_grad_int</span></div>

<div class="viewcode-block" id="KuboGreenwood.sig_to_N"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.KuboGreenwood.sig_to_N">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sig_to_N</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the integrated conducivity to electron number.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig : float</span>
<span class="sd">            integrated conducivity</span>
<span class="sd">        V : float</span>
<span class="sd">            volume of sphere</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        N_ele : float</span>
<span class="sd">            electron number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N_ele</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">N_ele</span></div></div>


<div class="viewcode-block" id="SphHamInts"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.SphHamInts">[docs]</a><span class="k">class</span> <span class="nc">SphHamInts</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Contains the functions needed to compute various spherical harmonic integrals.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SphHamInts.P_mat_int"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.SphHamInts.P_mat_int">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">P_mat_int</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func_int</span><span class="p">,</span> <span class="n">lmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix of P function (angular) integrals (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func_int : int</span>
<span class="sd">            the desired P integral (can be 2 or 4)</span>
<span class="sd">        lmax : int</span>
<span class="sd">            the maximum value of angular momentum</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        P_mat : ndarray</span>
<span class="sd">            matrix of P func integrals for chosen func_int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See Refs. [7]_ and [8]_ (supplemental material) for the definitions of the</span>
<span class="sd">        P2 and P4 functions, ands the :func:`P2_func`, :func:`P4_func` and</span>
<span class="sd">        :func:`P_int` functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmax</span><span class="p">):</span>
                <span class="c1"># sum rules mean all terms with l1!=l2 are zero</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># m cannot exceed either of l1 or l2</span>
                    <span class="n">lsmall</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">lsmall</span><span class="p">,</span> <span class="n">lsmall</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">P_mat</span><span class="p">[</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">lsmall</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">P_int</span><span class="p">(</span><span class="n">func_int</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
        <span class="k">return</span> <span class="n">P_mat</span></div>

<div class="viewcode-block" id="SphHamInts.P_int"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.SphHamInts.P_int">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">P_int</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func_int</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate the P2 or P4 function (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func_int : int</span>
<span class="sd">            the desired P integral (can be 2 or 4)</span>
<span class="sd">        l1 : int</span>
<span class="sd">            1st angular quantum number</span>
<span class="sd">        l2 : int</span>
<span class="sd">            2nd angular quantum number</span>
<span class="sd">        m : int</span>
<span class="sd">            magnetic quantum number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        P_int_ : float</span>
<span class="sd">            the integrated P2 or P4 function</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The integrals are defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \bar{P}^{(n)}_{ll&#39;m} = 2\pi c_{lm}c_{l&#39;m}\int_{-1}^1 dx \</span>
<span class="sd">                                   f_p^{(n)}[l_1,l_2,m](x)</span>

<span class="sd">        With the functions :math:`f_p^{(n)}(x)` defined below (:func:`P2_func`</span>
<span class="sd">        and :func:`P4_func`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func_int</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">integ</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">P2_func</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">func_int</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">integ</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">P4_func</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error: func_int value not recognised, must be 2 or 4&quot;</span><span class="p">)</span>

        <span class="n">P_int_</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">cls</span><span class="o">.</span><span class="n">sph_ham_coeff</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="bp">cls</span><span class="o">.</span><span class="n">sph_ham_coeff</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">integ</span>

        <span class="k">return</span> <span class="n">P_int_</span></div>

<div class="viewcode-block" id="SphHamInts.P2_func"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.SphHamInts.P2_func">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">P2_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the &#39;P2&#39; function (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            input for Legendre polynomial</span>
<span class="sd">        l1 : int</span>
<span class="sd">            1st angular quantum number</span>
<span class="sd">        l2 : int</span>
<span class="sd">            2nd angular quantum number</span>
<span class="sd">        m : int</span>
<span class="sd">            magnetic quantum number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        P2_func_ : float</span>
<span class="sd">            the P2 function</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The P2 function is defined as (see also Refs. [7]_ and [8]_)</span>

<span class="sd">        .. math::</span>
<span class="sd">            f_p^{(2)}[l_1,l_2,m](x) = x P_{l_1}^m (x) P_{l_2}^m (x)</span>

<span class="sd">        where P_{l}^m (x) are Legendre polynomial functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P2_func_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">P2_func_</span></div>

<div class="viewcode-block" id="SphHamInts.P4_func"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.SphHamInts.P4_func">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">P4_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the &#39;P4&#39; function (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            input for Legendre polynomial</span>
<span class="sd">        l1 : int</span>
<span class="sd">            1st angular quantum number</span>
<span class="sd">        l2 : int</span>
<span class="sd">            2nd angular quantum number</span>
<span class="sd">        m : int</span>
<span class="sd">            magnetic quantum number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        P4_func_ : float</span>
<span class="sd">            the P4 function</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The P4 function is defined as (see also Refs. [7]_ and [8]_)</span>

<span class="sd">        .. math::</span>
<span class="sd">            f_p^{(4)}[l_1,l_2,m](x)&amp;=-(1-x)^2 P^m_{l_1}(x) \frac{dP_{l_2}^m(x)}{dx}\\</span>
<span class="sd">                                    &amp;= P^m_{l_1}(x) [(l_2+m)P_{l_2-1}^m(x)-xl_2\</span>
<span class="sd">                                       P_{l_2}^m(x)]</span>

<span class="sd">        where :math:`P_{l}^m(x)` are Legendre polynomial functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l2</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">l2</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">l2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="o">-</span><span class="n">l2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span></div>

<div class="viewcode-block" id="SphHamInts.sph_ham_coeff"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.SphHamInts.sph_ham_coeff">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sph_ham_coeff</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute coefficients of spherical harmonic functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        l : int</span>
<span class="sd">           angular quantum number</span>
<span class="sd">        m : int</span>
<span class="sd">           magnetic quantum number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_lm : float</span>
<span class="sd">            coefficient for spherical harmonic function (l,m) (see notes)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The spherical harmonic functions with coefficients :math:`c_{lm}` are defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            Y_m^l(\theta,\phi) &amp;= c_{lm} P_l^m (\cos\theta) e^{im\phi}\\</span>
<span class="sd">            c_{lm} &amp;= \sqrt{\frac{(2l+1)(l-m)!}{4\pi(l+m)!}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_lm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c_lm</span></div></div>


<div class="viewcode-block" id="RadialInts"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts">[docs]</a><span class="k">class</span> <span class="nc">RadialInts</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Contains functions required to compute various integrals of the radial KS fns.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="RadialInts.calc_R1_int_mat"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts.calc_R1_int_mat">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">calc_R1_int_mat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">eigfuncs</span><span class="p">,</span> <span class="n">occnums</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the &#39;R1&#39; integral matrix (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigfuncs : ndarray</span>
<span class="sd">            the KS eigenfunctions</span>
<span class="sd">        occnums : ndarray</span>
<span class="sd">            the KS occupation numbers</span>
<span class="sd">        xgrid : ndarray</span>
<span class="sd">            the log grid</span>
<span class="sd">        orb_subset_1 : tuple</span>
<span class="sd">            the first subset of orbitals (eg valence)</span>
<span class="sd">        orb_subset_2 : tuple</span>
<span class="sd">            the second subset of orbitals (eg conduction)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R1_mat : ndarray</span>
<span class="sd">            the R1 integral matrix (see notes)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The definition of the R1 integral is (see Ref. [7]_ and supplementary of [8]_)</span>

<span class="sd">        .. math::</span>
<span class="sd">            R^{(1)}=4\pi\int_0^R dr r^2 X_{n_1 l_1}(r) \frac{dX_{n_2 l_2}(r)}{dr},</span>

<span class="sd">        where :math:`X_{nl}(r)` are the radial KS functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># take the derivative of orb2</span>
        <span class="c1"># compute the gradient of the orbitals</span>
        <span class="n">deriv_orb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">eigfuncs</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># chain rule to convert from dP_dx to dX_dr</span>
        <span class="n">grad_orb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">xgrid</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">deriv_orb2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">eigfuncs</span><span class="p">)</span>

        <span class="c1"># initiliaze the matrix</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">occnums</span><span class="p">)</span>
        <span class="n">R1_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbands</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># integrate over the sphere</span>
        <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">orb_subset_1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">orb_subset_2</span><span class="p">:</span>
                <span class="c1"># only l1 = l2 +/- 1 terms are non-zero</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">R1_mat</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">R1_int_term</span><span class="p">(</span>
                        <span class="n">eigfuncs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">],</span> <span class="n">grad_orb2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">],</span> <span class="n">xgrid</span>
                    <span class="p">)</span>
                    <span class="c1"># non-symmetric term</span>
                    <span class="k">if</span> <span class="n">orb_subset_1</span> <span class="o">!=</span> <span class="n">orb_subset_2</span><span class="p">:</span>
                        <span class="n">R1_mat</span><span class="p">[:,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">R1_int_term</span><span class="p">(</span>
                            <span class="n">eigfuncs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">],</span> <span class="n">grad_orb2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">],</span> <span class="n">xgrid</span>
                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">R1_mat</span></div>

<div class="viewcode-block" id="RadialInts.R1_int_term"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts.R1_int_term">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">R1_int_term</span><span class="p">(</span><span class="n">eigfunc</span><span class="p">,</span> <span class="n">grad_orb2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input function to the :func:`calc_R1_int_mat` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigfunc : ndarray</span>
<span class="sd">            KS orbital l1,n1</span>
<span class="sd">        grad_orb2 : ndarray</span>
<span class="sd">            derivative of KS orbital l2,n2</span>
<span class="sd">        xgrid : ndarray</span>
<span class="sd">            log grid</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R1_int : float</span>
<span class="sd">            the matrix element for the R1_int_mat function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func_int</span> <span class="o">=</span> <span class="n">eigfunc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xgrid</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_orb2</span>
        <span class="n">R1_int</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">xgrid</span><span class="p">)</span> <span class="o">*</span> <span class="n">func_int</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">R1_int</span></div>

<div class="viewcode-block" id="RadialInts.calc_R2_int_mat"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts.calc_R2_int_mat">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">calc_R2_int_mat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">eigfuncs</span><span class="p">,</span> <span class="n">occnums</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">,</span> <span class="n">orb_subset_1</span><span class="p">,</span> <span class="n">orb_subset_2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the &#39;R2&#39; integral matrix (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigfuncs : ndarray</span>
<span class="sd">            the KS eigenfunctions</span>
<span class="sd">        occnums : ndarray</span>
<span class="sd">            the KS occupation numbers</span>
<span class="sd">        xgrid : ndarray</span>
<span class="sd">            the log grid</span>
<span class="sd">        orb_subset_1 : tuple</span>
<span class="sd">            the first subset of orbitals (eg valence)</span>
<span class="sd">        orb_subset_2 : tuple</span>
<span class="sd">            the second subset of orbitals (eg conduction)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R2_mat : ndarray</span>
<span class="sd">            the R2 integral matrix (see notes)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The definition of the R2 integral is (see Ref. [7]_ and supplementary of [8]_)</span>

<span class="sd">        .. math::</span>
<span class="sd">            R^{(1)}=4\pi\int_0^R dr r X_{n_1 l_1}(r) X_{n_2 l_2}(r),</span>

<span class="sd">        where :math:`X_{nl}(r)` are the radial KS functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initiliaze the matrix</span>
        <span class="n">nbands</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">occnums</span><span class="p">)</span>
        <span class="n">R2_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbands</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">nmax</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># integrate over the sphere</span>
        <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">orb_subset_1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">orb_subset_2</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">R2_mat</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">R2_int_term</span><span class="p">(</span>
                        <span class="n">eigfuncs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">],</span> <span class="n">eigfuncs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">],</span> <span class="n">xgrid</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">orb_subset_1</span> <span class="o">!=</span> <span class="n">orb_subset_2</span><span class="p">:</span>

                        <span class="n">R2_mat</span><span class="p">[:,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">R2_int_term</span><span class="p">(</span>
                            <span class="n">eigfuncs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">n2</span><span class="p">],</span> <span class="n">eigfuncs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">n1</span><span class="p">],</span> <span class="n">xgrid</span>
                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">R2_mat</span></div>

<div class="viewcode-block" id="RadialInts.R2_int_term"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts.R2_int_term">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">R2_int_term</span><span class="p">(</span><span class="n">eigfunc_1</span><span class="p">,</span> <span class="n">eigfunc_2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input function to the :func:`calc_R2_int_mat` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eigfunc_1 : ndarray</span>
<span class="sd">            KS orbital l1,n1</span>
<span class="sd">        eigfunc_2 : ndarray</span>
<span class="sd">            KS orbital l2,n2</span>
<span class="sd">        xgrid : ndarray</span>
<span class="sd">            log grid</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R2_int : float</span>
<span class="sd">            the matrix element for the R2_int_mat function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R2_int</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xgrid</span><span class="p">)</span> <span class="o">*</span> <span class="n">eigfunc_1</span> <span class="o">*</span> <span class="n">eigfunc_2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">R2_int</span></div>

<div class="viewcode-block" id="RadialInts.calc_R1_int"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts.calc_R1_int">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_R1_int</span><span class="p">(</span><span class="n">orb1</span><span class="p">,</span> <span class="n">orb2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the R1 integral between two orbitals orb1 and orb2 (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orb1 : ndarray</span>
<span class="sd">            the first radial orbital</span>
<span class="sd">        orb2 : ndarray</span>
<span class="sd">            the second radial orbital</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R1_int : ndarray</span>
<span class="sd">            the R1 integral</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See :func:`calc_R1_int_mat` for definition of the integral</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># take the derivative of orb2</span>
        <span class="c1"># compute the gradient of the orbitals</span>
        <span class="n">deriv_orb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">orb2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># chain rule to convert from dP_dx to dX_dr</span>
        <span class="n">grad_orb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">xgrid</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">deriv_orb2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">orb2</span><span class="p">)</span>

        <span class="c1"># integrate over the sphere</span>
        <span class="n">func_int</span> <span class="o">=</span> <span class="n">orb1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xgrid</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_orb2</span>
        <span class="n">R1_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">xgrid</span><span class="p">)</span> <span class="o">*</span> <span class="n">func_int</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">R1_int</span></div>

<div class="viewcode-block" id="RadialInts.calc_R2_int"><a class="viewcode-back" href="../../../api/atoMEC.postprocess.html#atoMEC.postprocess.conductivity.RadialInts.calc_R2_int">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_R2_int</span><span class="p">(</span><span class="n">orb1</span><span class="p">,</span> <span class="n">orb2</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the R2 integral between two orbitals orb1 and orb2 (see notes).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orb1 : ndarray</span>
<span class="sd">            the first radial orbital</span>
<span class="sd">        orb2 : ndarray</span>
<span class="sd">            the second radial orbital</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R2_int : ndarray</span>
<span class="sd">            the R2 integral</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See :func:`calc_R2_int_mat` for definition of the integral</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xgrid</span><span class="p">)</span> <span class="o">*</span> <span class="n">orb1</span> <span class="o">*</span> <span class="n">orb2</span>
        <span class="n">R2_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">func_int</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">R2_int</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, CASUS.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>